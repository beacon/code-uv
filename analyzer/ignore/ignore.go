package ignore

import (
	"go/token"
	"log"
	"regexp"

	"golang.org/x/tools/go/analysis"
)

var regIgnore *regexp.Regexp
var regCodeGen *regexp.Regexp

func init() {
	regIgnore = regexp.MustCompile(`IGNORE_CODE_SCAN:{0,1}(.*)`)
	regCodeGen = regexp.MustCompile(`Code generated by.*DO NOT EDIT`)
}

const Doc = `Ignore scan by comments`

var Analyzer = &analysis.Analyzer{
	Name: "ignore",
	Doc:  Doc,
	Run:  run,
}

type IgnoreResult struct {
	Files map[string]struct{}
	Lines map[string]map[int]struct{}
}

func (r *IgnoreResult) IsIgnored(pass *analysis.Pass, p token.Pos) bool {
	pos := pass.Fset.Position(p)
	if _, ok := r.Files[pos.Filename]; ok {
		return true
	}

	if lineSet, ok := r.Lines[pos.Filename]; ok {
		_, ok = lineSet[pos.Line]
		return ok
	}

	return false
}

func run(pass *analysis.Pass) (interface{}, error) {
	result := &IgnoreResult{
		Files: make(map[string]struct{}),
		Lines: make(map[string]map[int]struct{}),
	}

	for _, f := range pass.Files {
		for _, cg := range f.Comments {
			if regCodeGen.MatchString(cg.Text()) {
				filePos := pass.Fset.File(cg.Pos())
				log.Println("The file is generated by 3rd party tool. Ignore", filePos.Name())
				break
			}

			pos := pass.Fset.Position(cg.Pos())
			lineSet := result.Lines[pos.Filename]
			if lineSet == nil {
				lineSet = make(map[int]struct{})
				result.Lines[pos.Filename] = lineSet
			}
			lineSet[pos.Line] = struct{}{}

			matches := regIgnore.FindStringSubmatch(cg.Text())
			if matches == nil {
				continue
			}
			if len(matches) > 1 {
				log.Println(cg.Pos(), "is ignored:", matches[1])
			}
		}
	}

	return result, nil
}
